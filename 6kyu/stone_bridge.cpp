/*
Description:
A special type of prime is generated by the formula 
p = 2^m * 3^n + 1 where m and n can be any non-negative 
integer.

The first 5 of these primes are 2, 3, 5, 7, 13, and are 
generated as follows:

2 = 2^0 * 3^0 + 1
3 = 2^1 * 3^0 + 1
5 = 2^2 * 3^0 + 1
7 = 2^1 * 3^1 + 1
13 = 2^2 * 3^1 + 1
..and so on
You will be given a range and your task is to return the 
number of primes that have this property. For example, 
solve(0,15) = 5, because there are only 5 such primes >= 0 
and < 15; they are 2,3,5,7,13. The upper limit of the tests 
will not exceed 1,500,000.

More examples in the test cases.

Good luck!
*/


#include <cmath>
#include <vector>
#include <algorithm>

std::vector<int> gerarPrimos(int n) {
    std::vector<bool> primo(n + 1, true);
    primo[0] = primo[1] = false;

    for (int i = 2; i * i <= n; ++i) {
        if (primo[i]) {
            for (int j = i * i; j <= n; j += i) {
                primo[j] = false;
            }
        }
    }

    std::vector<int> primos;
    for (int i = 2; i <= n; ++i) {
        if (primo[i])
            primos.push_back(i);
    }

    return primos;
}

bool special(int num){
  int pMinus1 = num-1;
  
    while(pMinus1 %2 == 0){
      pMinus1 = pMinus1 / 2;
    }
    while(pMinus1%3 == 0){
      pMinus1 = pMinus1 / 3;
    }
  return pMinus1 == 1;
}


int solve(int x, int y) {
  std::vector<int> primos;
  int total = 0;
  primos = gerarPrimos(y);
  
  for(int& val : primos){
    if(special(val) && val >= x && val < y){
      total++;
    }
  }
  
  return total;
}